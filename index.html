<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Brain Dump (Stable SVG)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { 
            background-color: #020617; 
            color: #f8fafc; 
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            -webkit-tap-highlight-color: transparent; 
        }
        ::-webkit-scrollbar { display: none; }
        .glass-header {
            background: rgba(2, 6, 23, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const API_VERSION = "v1beta";

        // --- Icons (SVG Direct Embedding to prevent React Crash) ---
        // Lucideを使わず、Reactコンポーネントとして直接定義することでDOM衝突を回避
        const Icons = {
            Brain: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z"/><path d="M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z"/><path d="M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4"/><path d="M17.599 6.5a3 3 0 0 0 .399-1.375"/><path d="M6.003 5.125A3 3 0 0 0 6.401 6.5"/><path d="M3.477 10.896a4 4 0 0 1 .585-.396"/><path d="M19.938 10.5a4 4 0 0 1 .585.396"/><path d="M6 18a4 4 0 0 1-1.97-3.284"/><path d="M17.97 14.716A4 4 0 0 1 18 18"/></svg>,
            Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>,
            Wind: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>,
            ArrowUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></svg>,
            Loader: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
        };

        const CATEGORY_COLORS = {
            "Work": "bg-blue-500",
            "Life": "bg-emerald-500",
            "Idea": "bg-amber-400",
            "Hobby": "bg-purple-500",
            "Learn": "bg-pink-500",
            "Other": "bg-slate-500"
        };

        // データ復旧・サニタイズ関数
        const loadAndSanitizeMemos = () => {
            try {
                const raw = localStorage.getItem("brain_dump_memos");
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return [];
                return parsed.map(memo => ({
                    id: memo.id || Date.now(),
                    text: typeof memo.text === 'string' ? memo.text : "",
                    title: typeof memo.title === 'string' ? memo.title : "無題",
                    category: CATEGORY_COLORS[memo.category] ? memo.category : "Other",
                    tags: Array.isArray(memo.tags) ? memo.tags : [],
                    timestamp: memo.timestamp || "--:--"
                }));
            } catch (e) {
                console.error("Resetting corrupted data", e);
                return [];
            }
        };

        const App = () => {
            // --- State ---
            const [hasKey, setHasKey] = useState(() => !!localStorage.getItem("gemini_api_key_brain"));
            const [apiKey, setApiKey] = useState(() => localStorage.getItem("gemini_api_key_brain") || "");
            
            // 安全なローダーを使用
            const [memos, setMemos] = useState(loadAndSanitizeMemos);
            
            // モデルリスト
            const [availableModels, setAvailableModels] = useState(() => {
                try { return JSON.parse(localStorage.getItem("brain_available_models") || "[]"); } catch { return []; }
            });
            const [selectedModel, setSelectedModel] = useState(() => localStorage.getItem("brain_selected_model") || "");

            const [inputText, setInputText] = useState("");
            const [isProcessing, setIsProcessing] = useState(false);
            
            // 検索・フィルター
            const [searchQuery, setSearchQuery] = useState("");
            const [activeTag, setActiveTag] = useState(null); 
            const [isSearchOpen, setIsSearchOpen] = useState(false);

            // --- Effects ---
            useEffect(() => { localStorage.setItem("brain_dump_memos", JSON.stringify(memos)); }, [memos]);
            
            // 初回モデル取得
            useEffect(() => {
                if (hasKey && apiKey && availableModels.length === 0) {
                    fetchModels(apiKey);
                }
            }, [hasKey]);

            // --- Logic ---
            const filteredMemos = useMemo(() => {
                return memos.filter(memo => {
                    const tags = Array.isArray(memo.tags) ? memo.tags : [];
                    
                    if (activeTag && !tags.includes(activeTag) && memo.category !== activeTag) return false;
                    
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        return (
                            (memo.title || "").toLowerCase().includes(q) ||
                            (memo.text || "").toLowerCase().includes(q) ||
                            tags.some(t => String(t).toLowerCase().includes(q))
                        );
                    }
                    return true;
                });
            }, [memos, searchQuery, activeTag]);

            const fetchModels = async (key) => {
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/${API_VERSION}/models?key=${key}`);
                    const data = await res.json();
                    if (!res.ok) return;
                    
                    const models = data.models
                        .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                        .map(m => m.name.replace("models/", ""))
                        .sort();
                    
                    setAvailableModels(models);
                    localStorage.setItem("brain_available_models", JSON.stringify(models));

                    if (!selectedModel && models.length > 0) {
                        const best = models.find(m => m.includes("27b")) || models.find(m => m.includes("12b")) || models[0];
                        setSelectedModel(best);
                        localStorage.setItem("brain_selected_model", best);
                    }
                } catch (e) { console.error(e); }
            };

            const processMemoWithAI = async (text) => {
                const target = selectedModel || "gemma-3-12b-it";
                const url = `https://generativelanguage.googleapis.com/${API_VERSION}/models/${target}:generateContent?key=${apiKey}`;
                const prompt = `あなたはメモ整理AIです。以下のテキストを分析しJSONで出力してください。\nテキスト: ${text}\nルール:\n1. JSONのみ出力\n2. "title": 15文字以内\n3. "category": [Work, Life, Idea, Hobby, Learn, Other]から選択\n4. "tags": 関連タグ2つ\n例: {"title":"買い物","category":"Life","tags":["スーパー","夕食"]}`;

                try {
                    const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error?.message);
                    
                    const rawText = data.candidates[0].content.parts[0].text;
                    const jsonStr = rawText.replace(/```json|```/g, "").trim();
                    const parsed = JSON.parse(jsonStr);
                    
                    return {
                        title: typeof parsed.title === 'string' ? parsed.title : text.slice(0, 15),
                        category: CATEGORY_COLORS[parsed.category] ? parsed.category : "Other",
                        tags: Array.isArray(parsed.tags) ? parsed.tags : [] 
                    };

                } catch (e) {
                    console.error("AI Error:", e);
                    return { title: text.slice(0, 15) + "...", category: "Other", tags: ["未分類"] };
                }
            };

            const handleSend = async () => {
                if (!inputText.trim() || isProcessing) return;
                const rawText = inputText;
                setInputText("");
                setIsProcessing(true);
                
                // 検索状態をリセットしてリスト全表示に戻す（これが以前はクラッシュ原因だった）
                setSearchQuery(""); setActiveTag(null); setIsSearchOpen(false);

                const analyzed = await processMemoWithAI(rawText);
                
                const newMemo = {
                    id: Date.now(),
                    text: rawText,
                    ...analyzed,
                    timestamp: new Date().toLocaleTimeString('ja-JP', {hour: '2-digit', minute:'2-digit'}),
                };
                
                setMemos(prev => [newMemo, ...prev]);
                setIsProcessing(false);
            };

            const deleteMemo = (id, e) => {
                e.stopPropagation();
                if(confirm("削除しますか？")) setMemos(prev => prev.filter(m => m.id !== id));
            };

            // --- Render ---
            if (!hasKey) return (
                <div className="h-screen bg-slate-950 flex flex-col items-center justify-center p-6 text-slate-50">
                    <div className="w-16 h-16 bg-slate-800 rounded-2xl flex items-center justify-center mb-6 text-teal-400 border border-slate-700">
                        <Icons.Brain />
                    </div>
                    <h1 className="text-3xl font-bold mb-8 tracking-tight text-teal-400">Brain Dump</h1>
                    <input type="text" value={apiKey} onChange={e=>setApiKey(e.target.value)} placeholder="API Key" className="w-full p-4 rounded-xl bg-slate-900 border border-slate-800 mb-6 text-white outline-none focus:border-teal-500"/>
                    <button onClick={()=> {if(apiKey.length<10)return; localStorage.setItem("gemini_api_key_brain", apiKey); setHasKey(true); fetchModels(apiKey);}} className="w-full bg-teal-600 py-4 rounded-xl font-bold text-white">Start</button>
                </div>
            );

            return (
                <div className="h-[100dvh] w-full flex flex-col bg-slate-950 relative overflow-hidden">
                    
                    {/* Header */}
                    <header className="glass-header border-b border-slate-800 absolute top-0 w-full z-20 flex flex-col transition-all duration-300">
                        <div className="h-14 flex justify-between items-center px-4">
                            {!isSearchOpen ? (
                                <div className="flex items-center gap-2 cursor-pointer" onClick={() => setActiveTag(null)}>
                                    <div className="text-teal-400"><Icons.Brain /></div>
                                    <h1 className="font-bold text-lg tracking-tight">Brain Dump</h1>
                                </div>
                            ) : (
                                <div className="flex-1 flex items-center gap-2 mr-2">
                                    <div className="text-slate-500"><Icons.Search /></div>
                                    <input autoFocus value={searchQuery} onChange={e => setSearchQuery(e.target.value)} placeholder="検索..." className="bg-transparent text-white w-full outline-none placeholder:text-slate-600" />
                                </div>
                            )}
                            <div className="flex gap-4 items-center">
                                <button onClick={() => { setIsSearchOpen(!isSearchOpen); if(isSearchOpen) setSearchQuery(""); }} className={`transition-colors ${isSearchOpen ? 'text-teal-400' : 'text-slate-400 hover:text-white'}`}>
                                    {isSearchOpen ? <div className="w-5 h-5"><Icons.X /></div> : <div className="w-5 h-5"><Icons.Search /></div>}
                                </button>
                                <div className="relative group w-5 h-5">
                                    <div className="text-slate-400 group-hover:text-white"><Icons.Settings /></div>
                                    <select onChange={e => {setSelectedModel(e.target.value); localStorage.setItem("brain_selected_model", e.target.value);}} value={selectedModel} className="absolute inset-0 opacity-0 cursor-pointer">
                                        {availableModels.length > 0 ? availableModels.map(m => <option key={m} value={m}>{m}</option>) : <option>Model...</option>}
                                    </select>
                                </div>
                            </div>
                        </div>
                        {activeTag && (
                            <div className="h-8 bg-teal-900/30 flex items-center px-4 gap-2 text-xs border-t border-slate-800/50">
                                <span className="text-teal-400 font-bold">Filter:</span>
                                <span className="bg-teal-500/20 text-teal-300 px-2 py-0.5 rounded-full flex items-center gap-1">
                                    #{activeTag}
                                    <button onClick={() => setActiveTag(null)} className="flex items-center"><div className="w-3 h-3"><Icons.X /></div></button>
                                </span>
                            </div>
                        )}
                    </header>

                    {/* Main List */}
                    <main className={`flex-1 overflow-y-auto w-full pb-20 transition-all ${activeTag ? 'pt-[88px]' : 'pt-14'}`}>
                        {filteredMemos.length === 0 ? (
                            <div className="h-full flex flex-col items-center justify-center text-slate-600 gap-4 opacity-50">
                                <div className="text-slate-700"><Icons.Wind /></div>
                                <p className="text-sm">{searchQuery || activeTag ? "見つかりません" : "思考をダンプしよう"}</p>
                            </div>
                        ) : (
                            <div className="flex flex-col">
                                {filteredMemos.map((memo) => {
                                    const barColor = CATEGORY_COLORS[memo.category] || "bg-slate-500";
                                    const tags = Array.isArray(memo.tags) ? memo.tags : [];
                                    
                                    return (
                                        <div key={memo.id} className="relative pl-5 pr-4 py-4 border-b border-slate-800/50 hover:bg-slate-900/50 transition-colors group">
                                            <div className={`absolute left-0 top-0 bottom-0 w-1.5 ${barColor}`}></div>
                                            
                                            <div className="flex justify-between items-start mb-1">
                                                <h3 className="font-bold text-slate-100 text-base leading-tight">{memo.title}</h3>
                                                <span className="text-[10px] text-slate-500 font-mono pt-1">{memo.timestamp}</span>
                                            </div>
                                            
                                            <p className="text-slate-400 text-sm line-clamp-2 mb-3 leading-relaxed opacity-90 whitespace-pre-wrap">{memo.text}</p>
                                            
                                            <div className="flex justify-between items-center">
                                                <div className="flex gap-2 flex-wrap">
                                                    <span onClick={() => setActiveTag(memo.category)} className="text-[10px] px-2 py-0.5 rounded-full bg-slate-800 text-slate-400 border border-slate-700 hover:border-teal-500 hover:text-teal-400 cursor-pointer transition-colors">
                                                        {memo.category}
                                                    </span>
                                                    {tags.map((tag, i) => (
                                                        <span key={i} onClick={() => setActiveTag(tag)} className="text-[10px] px-2 py-0.5 rounded-full bg-slate-800 text-slate-300 border border-slate-700 hover:border-teal-500 hover:text-teal-400 cursor-pointer transition-colors">
                                                            #{tag}
                                                        </span>
                                                    ))}
                                                </div>
                                                <button onClick={(e) => deleteMemo(memo.id, e)} className="text-slate-600 hover:text-red-400 p-2">
                                                    <div className="w-4 h-4"><Icons.Trash /></div>
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </main>

                    {/* Input Area */}
                    <div className="absolute bottom-0 w-full bg-slate-950 border-t border-slate-800 p-3 pb-safe z-30">
                        <div className="relative flex items-end gap-2 bg-slate-900 rounded-2xl border border-slate-800 p-1 focus-within:border-teal-500/50 transition-colors shadow-lg shadow-black/50">
                            <textarea 
                                value={inputText}
                                onChange={(e) => setInputText(e.target.value)}
                                onKeyDown={(e) => { if(e.key === 'Enter' && (e.metaKey || e.ctrlKey)) handleSend(); }}
                                placeholder="書き出す..." 
                                className="w-full bg-transparent text-slate-200 text-sm p-3 outline-none resize-none max-h-32 min-h-[48px] placeholder:text-slate-600"
                                rows="1"
                            />
                            <button 
                                onClick={handleSend} 
                                disabled={isProcessing || !inputText.trim()}
                                className={`p-3 rounded-xl mb-0.5 transition-all ${
                                    inputText.trim() 
                                    ? 'bg-teal-600 text-white shadow-lg active:scale-95' 
                                    : 'bg-slate-800 text-slate-500'
                                }`}
                            >
                                {isProcessing ? <div className="w-5 h-5 animate-spin"><Icons.Loader /></div> : <div className="w-5 h-5"><Icons.ArrowUp /></div>}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
