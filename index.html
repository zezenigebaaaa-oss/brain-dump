<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Brain Dump (Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { 
            background-color: #020617; 
            color: #f8fafc; 
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            -webkit-tap-highlight-color: transparent; 
        }
        ::-webkit-scrollbar { display: none; }
        .glass-header {
            background: rgba(2, 6, 23, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const API_VERSION = "v1beta";

        const CATEGORY_COLORS = {
            "Work": "bg-blue-500",
            "Life": "bg-emerald-500",
            "Idea": "bg-amber-400",
            "Hobby": "bg-purple-500",
            "Learn": "bg-pink-500",
            "Other": "bg-slate-500"
        };

        // 安全にLocalStorageを読み込むヘルパー関数（バグ回避の要）
        const safeJSONParse = (key, fallback) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : fallback;
            } catch (e) {
                console.error(`Error parsing ${key}:`, e);
                return fallback;
            }
        };

        const App = () => {
            // --- State Initialization ---
            const [hasKey, setHasKey] = useState(() => !!localStorage.getItem("gemini_api_key_brain"));
            const [apiKey, setApiKey] = useState(() => localStorage.getItem("gemini_api_key_brain") || "");
            
            const [availableModels, setAvailableModels] = useState(() => safeJSONParse("brain_available_models", []));
            const [selectedModel, setSelectedModel] = useState(() => localStorage.getItem("brain_selected_model") || "");

            const [memos, setMemos] = useState(() => safeJSONParse("brain_dump_memos", []));
            const [inputText, setInputText] = useState("");
            const [isProcessing, setIsProcessing] = useState(false);
            
            // Search & Filter
            const [searchQuery, setSearchQuery] = useState("");
            const [activeTag, setActiveTag] = useState(null); 
            const [isSearchOpen, setIsSearchOpen] = useState(false);

            // --- Effects ---
            useEffect(() => { localStorage.setItem("brain_dump_memos", JSON.stringify(memos)); }, [memos]);
            
            // アイコン初期化
            useEffect(() => { if (window.lucide) window.lucide.createIcons(); }, [hasKey, memos, isSearchOpen, activeTag]);

            // 初回起動時のモデル取得（API節約ロジック）
            useEffect(() => {
                if (hasKey && apiKey && availableModels.length === 0) {
                    fetchModels(apiKey);
                }
            }, [hasKey]);

            // --- Logic ---
            const filteredMemos = useMemo(() => {
                return memos.filter(memo => {
                    // タグ/カテゴリフィルター
                    if (activeTag && !memo.tags.includes(activeTag) && memo.category !== activeTag) return false;
                    
                    // 文字列検索
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        return (
                            memo.title.toLowerCase().includes(q) ||
                            memo.text.toLowerCase().includes(q) ||
                            (memo.tags && memo.tags.some(t => t.toLowerCase().includes(q)))
                        );
                    }
                    return true;
                });
            }, [memos, searchQuery, activeTag]);

            const fetchModels = async (key) => {
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/${API_VERSION}/models?key=${key}`);
                    const data = await res.json();
                    if (!res.ok) return; // エラー時は何もしない（既存リストがあればそれを使う）
                    
                    const models = data.models
                        .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                        .map(m => m.name.replace("models/", ""))
                        .sort();
                    
                    setAvailableModels(models);
                    localStorage.setItem("brain_available_models", JSON.stringify(models));

                    if (!selectedModel && models.length > 0) {
                        const best = models.find(m => m.includes("27b")) || models.find(m => m.includes("12b")) || models[0];
                        setSelectedModel(best);
                        localStorage.setItem("brain_selected_model", best);
                    }
                } catch (e) { console.error("Model fetch failed", e); }
            };

            const processMemoWithAI = async (text) => {
                const target = selectedModel || "gemma-3-12b-it";
                const url = `https://generativelanguage.googleapis.com/${API_VERSION}/models/${target}:generateContent?key=${apiKey}`;
                const prompt = `あなたはメモ整理AIです。以下のテキストを分析しJSONで出力してください。\nテキスト: ${text}\nルール:\n1. JSONのみ出力\n2. "title": 15文字以内\n3. "category": [Work, Life, Idea, Hobby, Learn, Other]から選択\n4. "tags": 関連タグ2つ\n例: {"title":"買い物","category":"Life","tags":["スーパー","夕食"]}`;

                try {
                    const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error?.message);
                    
                    const rawText = data.candidates[0].content.parts[0].text;
                    const jsonStr = rawText.replace(/```json|```/g, "").trim();
                    return JSON.parse(jsonStr);
                } catch (e) {
                    console.error("AI Gen Error", e);
                    return { title: text.slice(0, 15) + "...", category: "Other", tags: ["未分類"] };
                }
            };

            const handleSend = async () => {
                if (!inputText.trim() || isProcessing) return;
                const rawText = inputText;
                setInputText("");
                setIsProcessing(true);
                
                // 検索リセット
                setSearchQuery(""); setActiveTag(null); setIsSearchOpen(false);

                const analyzed = await processMemoWithAI(rawText);
                const newMemo = {
                    id: Date.now(),
                    text: rawText,
                    ...analyzed,
                    tags: analyzed.tags || [], // 安全策
                    timestamp: new Date().toLocaleTimeString('ja-JP', {hour: '2-digit', minute:'2-digit'}),
                };
                setMemos(prev => [newMemo, ...prev]);
                setIsProcessing(false);
            };

            const deleteMemo = (id, e) => {
                e.stopPropagation();
                if(confirm("削除しますか？")) setMemos(prev => prev.filter(m => m.id !== id));
            };

            // --- Render: Login ---
            if (!hasKey) return (
                <div className="h-screen bg-slate-950 flex flex-col items-center justify-center p-6 text-slate-50">
                    <h1 className="text-3xl font-bold mb-8 tracking-tight text-teal-400">Brain Dump</h1>
                    <input type="text" value={apiKey} onChange={e=>setApiKey(e.target.value)} placeholder="API Key" className="w-full p-4 rounded-xl bg-slate-900 border border-slate-800 mb-6 text-white outline-none focus:border-teal-500"/>
                    <button onClick={()=> {if(apiKey.length<10)return; localStorage.setItem("gemini_api_key_brain", apiKey); setHasKey(true); fetchModels(apiKey);}} className="w-full bg-teal-600 py-4 rounded-xl font-bold">Start</button>
                </div>
            );

            // --- Render: App ---
            return (
                <div className="h-[100dvh] w-full flex flex-col bg-slate-950 relative overflow-hidden">
                    
                    {/* Header */}
                    <header className="glass-header border-b border-slate-800 absolute top-0 w-full z-20 flex flex-col transition-all duration-300">
                        {/* Top Row: Title & Search */}
                        <div className="h-14 flex justify-between items-center px-4">
                            {!isSearchOpen ? (
                                <div className="flex items-center gap-2" onClick={() => setActiveTag(null)}>
                                    <i data-lucide="brain-circuit" className="w-5 h-5 text-teal-400"></i>
                                    <h1 className="font-bold text-lg tracking-tight cursor-pointer">Brain Dump</h1>
                                </div>
                            ) : (
                                <div className="flex-1 flex items-center gap-2 mr-2">
                                    <i data-lucide="search" className="w-4 h-4 text-slate-500"></i>
                                    <input 
                                        autoFocus
                                        value={searchQuery}
                                        onChange={e => setSearchQuery(e.target.value)}
                                        placeholder="検索..." 
                                        className="bg-transparent text-white w-full outline-none placeholder:text-slate-600"
                                    />
                                </div>
                            )}

                            <div className="flex gap-4 items-center">
                                {/* Search Toggle Button */}
                                <button onClick={() => { setIsSearchOpen(!isSearchOpen); if(isSearchOpen) setSearchQuery(""); }} className={`transition-colors ${isSearchOpen ? 'text-teal-400' : 'text-slate-400 hover:text-white'}`}>
                                    {isSearchOpen ? <i data-lucide="x" className="w-5 h-5"></i> : <i data-lucide="search" className="w-5 h-5"></i>}
                                </button>
                                {/* Model Selector */}
                                <div className="relative group">
                                    <i data-lucide="settings-2" className="w-5 h-5 text-slate-400 group-hover:text-white"></i>
                                    <select onChange={e => {setSelectedModel(e.target.value); localStorage.setItem("brain_selected_model", e.target.value);}} value={selectedModel} className="absolute inset-0 opacity-0 cursor-pointer">
                                        {availableModels.length > 0 ? availableModels.map(m => <option key={m} value={m}>{m}</option>) : <option>Loading...</option>}
                                    </select>
                                </div>
                            </div>
                        </div>

                        {/* Filter Bar (Visible only when activeTag is set) */}
                        {activeTag && (
                            <div className="h-8 bg-teal-900/30 flex items-center px-4 gap-2 text-xs border-t border-slate-800/50">
                                <span className="text-teal-400 font-bold">Filter:</span>
                                <span className="bg-teal-500/20 text-teal-300 px-2 py-0.5 rounded-full flex items-center gap-1">
                                    #{activeTag}
                                    <button onClick={() => setActiveTag(null)}><i data-lucide="x" className="w-3 h-3"></i></button>
                                </span>
                            </div>
                        )}
                    </header>

                    {/* Main List */}
                    <main className={`flex-1 overflow-y-auto w-full pb-20 transition-all ${activeTag ? 'pt-[88px]' : 'pt-14'}`}>
                        {filteredMemos.length === 0 ? (
                            <div className="h-full flex flex-col items-center justify-center text-slate-600 gap-4 opacity-50">
                                <i data-lucide="wind" className="w-12 h-12"></i>
                                <p className="text-sm">{searchQuery || activeTag ? "見つかりません" : "思考をダンプしよう"}</p>
                            </div>
                        ) : (
                            <div className="flex flex-col">
                                {filteredMemos.map((memo) => {
                                    const barColor = CATEGORY_COLORS[memo.category] || "bg-slate-500";
                                    return (
                                        <div key={memo.id} className="relative pl-5 pr-4 py-4 border-b border-slate-800/50 hover:bg-slate-900/50 transition-colors group">
                                            {/* Colored Bar */}
                                            <div className={`absolute left-0 top-0 bottom-0 w-1.5 ${barColor}`}></div>
                                            
                                            <div className="flex justify-between items-start mb-1">
                                                <h3 className="font-bold text-slate-100 text-base leading-tight">{memo.title}</h3>
                                                <span className="text-[10px] text-slate-500 font-mono pt-1">{memo.timestamp}</span>
                                            </div>
                                            
                                            <p className="text-slate-400 text-sm line-clamp-2 mb-3 leading-relaxed opacity-90 whitespace-pre-wrap">{memo.text}</p>
                                            
                                            <div className="flex justify-between items-center">
                                                <div className="flex gap-2 flex-wrap">
                                                    {/* Clickable Category */}
                                                    <span onClick={() => setActiveTag(memo.category)} className="text-[10px] px-2 py-0.5 rounded-full bg-slate-800 text-slate-400 border border-slate-700 hover:border-teal-500 hover:text-teal-400 cursor-pointer transition-colors">
                                                        {memo.category}
                                                    </span>
                                                    {/* Clickable Tags */}
                                                    {memo.tags && memo.tags.map((tag, i) => (
                                                        <span key={i} onClick={() => setActiveTag(tag)} className="text-[10px] px-2 py-0.5 rounded-full bg-slate-800 text-slate-300 border border-slate-700 hover:border-teal-500 hover:text-teal-400 cursor-pointer transition-colors">
                                                            #{tag}
                                                        </span>
                                                    ))}
                                                </div>
                                                <button onClick={(e) => deleteMemo(memo.id, e)} className="text-slate-600 hover:text-red-400 p-2">
                                                    <i data-lucide="trash-2" className="w-4 h-4"></i>
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </main>

                    {/* Input Area */}
                    <div className="absolute bottom-0 w-full bg-slate-950 border-t border-slate-800 p-3 pb-safe z-30">
                        <div className="relative flex items-end gap-2 bg-slate-900 rounded-2xl border border-slate-800 p-1 focus-within:border-teal-500/50 transition-colors shadow-lg shadow-black/50">
                            <textarea 
                                value={inputText}
                                onChange={(e) => setInputText(e.target.value)}
                                onKeyDown={(e) => { if(e.key === 'Enter' && (e.metaKey || e.ctrlKey)) handleSend(); }}
                                placeholder="書き出す..." 
                                className="w-full bg-transparent text-slate-200 text-sm p-3 outline-none resize-none max-h-32 min-h-[48px] placeholder:text-slate-600"
                                rows="1"
                            />
                            <button 
                                onClick={handleSend} 
                                disabled={isProcessing || !inputText.trim()}
                                className={`p-3 rounded-xl mb-0.5 transition-all ${
                                    inputText.trim() 
                                    ? 'bg-teal-600 text-white shadow-lg active:scale-95' 
                                    : 'bg-slate-800 text-slate-500'
                                }`}
                            >
                                {isProcessing ? <i data-lucide="loader-2" className="w-5 h-5 animate-spin"></i> : <i data-lucide="arrow-up" className="w-5 h-5"></i>}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
